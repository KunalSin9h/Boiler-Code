extends c

##
## Preprocessor
# #include <...>
snippet incc
	#include <${1:iostream}>
snippet binc
	#include <boost/${1:shared_ptr}.hpp>

##
## c code
snippet c
	#include <stdio.h>
	
	int main(){
		$0
		return 0;
	}

snippet cp
	#include <iostream>
	using namespace std;

	int main(){
		$0
		return 0;
	}
snippet cpp
	#include "bits/stdc++.h"
	using namespace std;

	#ifndef LOCAL
	#define dbg(x...)
	#endif

	int main(){
		cin.tie(0)->sync_with_stdio(0);
		$0
		return 0;
	}

##
## test case
snippet t
	int T;cin >> T;
	while(T--){

		$0

	}	

snippet tt
	int Test;cin >> Test;
	for(int Test_num = 1; Test_num <= Test; Test_num++){
		
		$0
		
		cout << "Case #" << Test_num << ": ";
	}

##time
snippet time
	cerr << fixed << (((float)clock()-beg)/CLOCKS_PER_SEC) << endl;

## all(x)
snippet all
	$1.begin(), $1.end()
##
## STL Collections
# std::array
snippet arr
	array<${1:T}, ${2:N}> ${3};
# std::vector
snippet v
	vector<${1:T}> ${2};
snippet vv
	vector<vector<$1>> $2($3, vector<$1>($4));
# std::deque
snippet dq
	deque<${1:T}> ${2};
# std::forward_list
snippet flist
	forward_list<${1:T}> ${2};
# std::list
snippet list
	list<${1:T}> ${2};
# std::set
snippet set
	set<${1:T}> ${2};
# std::map
snippet map
	map<${1:Key}, ${2:T}> ${3};
# std::multiset
snippet mset
	multiset<${1:T}> ${2};
# std::multimap
snippet mmap
	multimap<${1:Key}, ${2:T}> ${3};
# std::unordered_set
snippet uset
	unordered_set<${1:T}> ${2};
# std::unordered_map
snippet umap
	unordered_map<${1:Key}, ${2:T}> ${3};
# std::unordered_multiset
snippet umset
	unordered_multiset<${1:T}> ${2};
# std::unordered_multimap
snippet ummap
	unordered_multimap<${1:Key}, ${2:T}> ${3};
# std::stack
snippet stack
	stack<${1:T}> ${2};
# std::queue
snippet q
	queue<${1:T}> ${2};
# std::priority_queue
snippet pq
	priority_queue<${1:T}> ${2};

##
## STL smart pointers
# std::shared_ptr
snippet msp
	std::shared_ptr<${1:T}> ${2} = std::make_shared<$1>(${3});
snippet amsp
	auto ${1} = std::make_shared<${2:T}>(${3});
# std::unique_ptr
snippet mup
	std::unique_ptr<${1:T}> ${2} = std::make_unique<$1>(${3});
snippet amup
	auto ${1} = std::make_unique<${2:T}>(${3});
##
## Access Modifiers
# private
snippet pri
	private
# protected
snippet pro
	protected
# public
snippet pub
	public
# friend
snippet fr
	friend
# mutable
snippet mu
	mutable

snippet sort
	sort($1.begin(), $1.end())
snippet bs
	binary_search($1.begin(), $1.end(), $0)
snippet mi
	min_element($1.begin(), $1.end())
snippet mx
	max_element($1.begin(), $1.end())

# namespace
snippet ns
	namespace ${1:`vim_snippets#Filename('', 'my')`} {
		${0}
	} // namespace $1 

##
## Input/Output
# std::cout
snippet co
	cout << ${1} << '\n';
# std::cin
snippet ci
	cin >> ${1};
##
## Casts
# static
snippet sca
	static_cast<${1:unsigned}>(${2:expr})${3}
# dynamic
snippet dca
	dynamic_cast<${1:unsigned}>(${2:expr})${3}
# reinterpret
snippet rca
	reinterpret_cast<${1:unsigned}>(${2:expr})${3}
# const
snippet cca
	const_cast<${1:unsigned}>(${2:expr})${3}
## Iteration
# for i
snippet fori
	for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${4}
	}

# foreach
snippet fore
	for (${1:auto} ${2:i} : ${3:container}) {
		${4}
	}
# iterator
snippet iter
	for (${1:std::vector}<${2:type}>::${3:const_iterator} ${4:i} = ${5:container}.begin(); $4 != $5.end(); ++$4) {
		${6}
	}

# auto iterator
snippet itera
	for (auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1) {
		${3:std::cout << *$1 << std::endl;}
	}
##
## Lambdas
# lamda (one line)
snippet ld
	[${1}](${2}){${3}};
# lambda (multi-line)
snippet lld
	[&](${2}){
		${3}
	};
# snippets exception
snippet try
	try {

	}catch(${1}) {

	}
